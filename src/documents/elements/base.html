---
standalone: true
---

<link rel="import" href="#{SITE_URL}bower_components/polymer/polymer.html" />

<!--
The RTC Media
This is what captures the media and exports it as a stream and streamURI
-->
<polymer-element name="rtc-media" attributes="capture stream streamURI">
	<script src="//wzrd.in/bundle/rtc-media@~1.5.1"></script>
	<script src="//wzrd.in/bundle/rtc-captureconfig@~0.4.0"></script>
	<template></template>
	<script>
		Polymer('rtc-media', {
			capture: 'camera max:320x240',
			stream: null,
			streamURI: null,
			ready: function(){
				var me = this;
				var constraints = require('rtc-captureconfig')(me.capture).toConstraints();
				var media = require("rtc-media")({
					constraints: constraints
				});
				media.once('capture', function(stream){
					me.stream = stream;
					me.streamURI = window.URL.createObjectURL(stream);
				});
			}
		});
	</script>
</polymer-element>

<!--
The RTC Video
This displays our streamURI as a playing video
-->
<polymer-element name="rtc-video" attributes="src video playing muted">
	<template>
		<video id="video" mozSrcObject="{{src}}" src="{{src}}" muted?="{{muted}}" preserveaspectratio></video>
	</template>
	<script>
		Polymer('rtc-video', {
			src: null,
			video: null,
			muted: false,
			playing: true,
			ready: function(){
				this.refresh();
				this.refresh = this.refresh.bind(this);
			},
			refresh: function(){
				var me = this;
				var video = me.$.video;

				// Apply the element to our model for data binding
				me.video = video;

				// If we are playing, play the video
				if ( me.src && me.playing ) {
					setTimeout(function(){
						video.play();
					}, 0);
				}

				// If we are not playing, pause the video
				else {
					video.pause();
				}
			},
			srcChanged: function(){
				this.refresh();
			},
			playingChanged: function(){
				this.refresh();
			}
		});
	</script>
</polymer-element>

<!--
This RTC VideoProc
This takes a src (video element or streamURI — streamURI not support yet) and generates an imageURI with the filters applied
-->
<polymer-element name="rtc-videoproc" attributes="src filter fps mime quality greedy imageURI">
	<script src="//wzrd.in/bundle/dominject@~1.0.3"></script>
	<script src="//wzrd.in/bundle/rtc-videoproc-bal@~0.8.2"></script>
	<template>
		<canvas id="canvas"></canvas>
	</template>
	<script>
		Polymer('rtc-videoproc', {
			fps: 0.5,
			mime: 'image/jpeg',
			quality: 0.8,
			greedy: true,
			filter: null,  // grayscale
			filterMethod: null,
			src: null,
			videoproc: null,
			imageURI: null,
			refresh: function(){
				var me = this;
				if ( me.src && me.filterMethod ) {
					me.videoproc = require('rtc-videoproc-bal')({
						video: me.src,
						canvas: me.$.canvas,
						fps: me.fps,
						greedy: me.greedy,
					});

					me.videoproc.pipeline.add(me.filterMethod);

					me.videoproc.addEventListener('postprocess', function(event){
						me.imageURI = me.videoproc.toDataURL(me.mime, me.quality);
					});
				}
			},
			filterChanged: function(oldValue, newValue) {
				var me = this;
				if ( newValue ) {
					var filterSource = '//wzrd.in/bundle/rtc-filter-'+newValue+'@latest';
					var dominject = require('dominject');
					dominject({
						type: 'script',
						url: filterSource,
						next: function(err, element) {
							if ( err ) {
								console.log(err);
							} else {
								try {
									me.filterMethod = require('rtc-filter-'+me.filter);
								} catch (err) {
									console.log(err);
									return;
								}

								me.refresh.call(me);
							}
						}
					});
				}
			},
			srcChanged: function(oldValue, newValue) {
				this.refresh();
			}
		});
	</script>
</polymer-element>

<!--
===============================================================================
-->

<!--
# The RTC Person
This is a view and model representing each person within the chat room.
Each person has a name, a video stream, and a low-bandwidth snapshot stream.
When the video stream is enabled, the low-bandwidth snapshot stream should
  be disabled and vice versa.
-->
<polymer-element name="rtc-person" attributes="streaming video name muted streamURI snapshotURI">
	<template>
		<div id="person">
			<label id="name" class="visible">{{name}}</label>
			<rtc-video id="video" class="hidden" src="{{streamURI}}" video="{{video}}" muted?="{{muted}}" playing?="{{streaming}}"></rtc-video>
			<img id="image" class="hidden" src="{{snapshotURI}}" />
		</div>
	</template>
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		#person, #video, #image {
			display: inline-block;
			width: 320px;
			height: 240px;
		}
		#person {
			position: relative;
			border: 1px solid black;
			background: #EEE;
			overflow: hidden;
		}
		#name {
			position: absolute;
			width: 100%;
			background: black;
			background: rgba(0,0,0,0.1);
			color: white;
			bottom: -1em;
			left: 0;
			text-align: center;
			font-family: monospace;
			line-height: 1em;
			transition: 0.1s bottom ease-in;
		}
		#person:hover #name, #name.visible {
			bottom: 0;
		}
		.hidden {
			display: none !important;
		}
	</style>
	<script>
		Polymer('rtc-person', {
			video: null,
			streaming: false,
			name: null,
			muted: false,
			streamURI: null,
			snapshotURI: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
			ready: function(){
				this.refresh();
			},
			refresh: function(){
				var me = this;
				var name = me.$.name;
				var video = me.$.video;
				var image = me.$.image;

				// If we are streaming, show the video
				if ( me.streamURI && me.streaming ) {
					video.className = '';
					image.className = 'hidden';
				}

				// If we are not streaming, show the snapshot
				else if ( me.snapshotURI ) {
					video.className = 'hidden';
					image.className = '';
				}

				else {
					image.className = video.className = 'hidden';
				}

				// Hide the name
				setTimeout(function(){
					name.className = '';
				}, 5000);
			},
			streamURIChanged: function(){
				this.refresh();
			},
			streamingChanged: function(){
				this.refresh();
			}
		});
	</script>
</polymer-element>

<!--
# The RTC Room Panel
This is the display for our people within the chat room.
Talking people are arranged first. They will be displayed big (TODO).
Then it is ourself. Then the people streaming whom aren't muted.
Then the people streaming whom are muted.
Then finally, everyone else (the people in snapshot mode).
-->
<polymer-element name="rtc-room-panel" lightdom noscript>
	<template>
		<content select="rtc-person"></content>
		<content select="rtc-peer[streaming]:not([muted])"></content>
		<content select="rtc-peer[streaming][muted]"></content>
		<content select="*"></content>
	</template>
</polymer-element>

<!--
# The RTC App
This is us initialising our room and it working with all the magic.
-->
<link rel="import" href="#{SITE_URL}bower_components/polymer-localstorage/polymer-localstorage.html">
<polymer-element name="rtc-app" attributes="host room">
	<style>
		.hidden {
			display: none !important;
		}
	</style>
	<script src="//wzrd.in/bundle/rtc-quickconnect@~0.8.3"></script>
	<template>
		<polymer-localstorage name="my-name" value="{{myName}}" polymer-localstorage-load="{{getName}}"></polymer-localstorage>
		<rtc-media id="media" stream="{{myStream}}" streamURI="{{myStreamURI}}" muted></rtc-media>
		<rtc-room-panel id="people">
			<rtc-person id="me" name="{{myName}}" streamURI="{{myStreamURI}}" video="{{myVideo}}" streaming muted></rtc-person>
		</rtc-room-panel>
		<rtc-videoproc id="snapshot" class="hidden" src="{{myVideo}}" imageURI="{{mySnapshotURI}}" filter="grayscale"></rtc-videoproc>
	</template>
	<script>
		Polymer('rtc-app', {
			room: 'interconnect',
			host: location.href.indexOf('github.io') !== -1 ? 'http://rtc.io/switchboard/' : location.href.replace(/(^.*\/).*$/, "$1"),
			peers: null,
			myStream: null,
			myName: null,
			myStreamURI: null,
			mySnapshotURI: null,
			myVideo: null,
			startStream: function(peerID) {
				var me = this;
				var peer = me.getPeer(peerID);
				if ( !peer.streaming ) {
					var stream = me.myStream;
					console.log('start stream', peerID, stream);
					peer.connection.addStream(stream);

					//peer.removeAttribute('muted');
					//peer.setAttribute('streaming', '');
					peer.streaming = true;
					peer.muted = false;

					peer.sendMessage({
						action: 'started-stream'
					});
				}
			},
			stopStream: function(peerID) {
				var me = this;
				var peer = me.getPeer(peerID);
				if ( peer.streaming ) {
					var stream = me.myStream;
					console.log('stop stream', peerID, stream);
					peer.connection.removeStream(stream);

					//peer.removeAttribute('streaming');
					//peer.setAttribute('muted', '');
					peer.streaming = false;
					peer.muted = true;

					peer.sendMessage({
						action: 'stopped-stream'
					});
				}
			},
			getPeer: function(peerID) {
				var me = this;
				var peer = me.peers[peerID] || null;
				if ( peer === null ) {
					peer = document.createElement('rtc-person');
					me.peers[peerID] = peer;
					me.$.people.appendChild(peer);
				}
				return peer;
			},
			destroyPeer: function(peerID) {
				var me = this;
				var peer = me.peers[peerID] || null;
				if ( peer) {
					peer.parentNode.removeChild(peer);
					delete me.peers[peerID];
				}
				return null;
			},
			getName: function(){
				var me = this;
				while ( !me.myName ) {
					me.myName = prompt('What is your name?');
				}
				me.sendMessage({
					action: 'meta',
					meta: {
						name: me.myName
					}
				});
			},
			sendMessage: function(data){
				var me = this;
				var message = JSON.stringify(data);
				Object.keys(me.peers).forEach(function(peerID){
					var peer = me.peers[peerID];
					peer.sendMessage(message);
				});
			},
			ready: function(){
				var me = this;
				me.peers = {};
				setTimeout(me.getName.bind(me), 1000); // workaround for https://github.com/Polymer/polymer/issues/404
				me.signaller = require('rtc-quickconnect')(me.host, {reactive: true, room: me.room, debug:false});
				me.signaller
					.createDataChannel('messages')
					.on('messages:open', function(peerChannel, peerID){
						var peer = me.getPeer(peerID);
						peer.channel = peerChannel;

						peer.sendMessage = function(data){
							if ( data.action !== 'snap' )  console.log('send message', data, 'to', peerID);
							var message = JSON.stringify(data);
							peer.channel.send(message);
						};

						peer.sendMessage({
							action: 'meta',
							meta: {
								name: me.myName
							}
						});

						peer.channel.onmessage = function(event) {
							var data = JSON.parse(event.data || '{}') || {};
							if ( data.action !== 'snap' )  console.log('received message', data, 'from', peerID);

							// console.log('remote stream', peerID, peer.connection.getLocalStreams(), peer.connection.getRemoteStreams());

							switch (data.action) {
								// Peer has sent us their latest meta data
								case 'meta':
									peer.name = (data.meta || {}).name;
									break;

								// Peer has sent their stream to us
								case 'started-stream':
									me.startStream(peerID);
									break;

								// Peer has cancelled their stream
								case 'stopped-stream':
									me.stopStream(peerID);
									break;

								// Peer has sent us their latest snapshot
								case 'snap':
									peer.snapshotURI = data.snapshotURI;
									break;
							}
						};
					})
					.on('peer:connect', function(peerConnection, peerID, data, monitor){
						console.log('connected to', peerID);
						var peer = me.getPeer(peerID);
						peer.className += 'peer';
						peer.streaming = false;
						peer.muted = false;
						peer.connection = peerConnection;
						peer.name = peer.id = peerID;

						peer.addEventListener('click', function(){
							if ( peer.streaming ) {
								me.stopStream(peerID);
							} else {
								me.startStream(peerID);
							}
						});

						peerConnection.onaddstream = function(event) {
							console.log('RECEIVED STREAM', 'from', peerID);
							peer.stream = event.stream;
							peer.streamURI = window.URL.createObjectURL(peer.stream);
							peer.stream.onended = function(){
								me.stopStream(peerId);
							};
							me.startStream(peerID);
						};

						peerConnection.onremovestream = function(event) {
							me.stopStream(peerId);
						};
					})
					.on('peer:leave', function(peerID){
						console.log('disconnected to', peerID);
						me.destroyPeer(peerID);
					});
			},
			mySnapshotURIChanged: function(oldValue, newValue){
				var me = this;
				if ( newValue ) {
					Object.keys(me.peers).forEach(function(peerID){
						var peer = me.peers[peerID];
						peer.sendMessage({
							action: 'snap',
							snapshotURI: newValue
						});
					});
				}
			}
		});
	</script>
</polymer-element>
