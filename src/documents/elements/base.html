---
standalone: true
---

<link rel="import" href="#{SITE_URL}bower_components/polymer/polymer.html" />

<!--
The RTC Media
This is what captures the media and exports it as a stream and streamURI
-->
<polymer-element name="rtc-media" attributes="stream muted capture streamURI">
	<script src="//wzrd.in/bundle/rtc-media@latest"></script>
	<script src="//wzrd.in/bundle/rtc-captureconfig@latest"></script>
	<template></template>
	<script>
		Polymer('rtc-media', {
			muted: true,
			capture: 'camera max:320x240',
			ready: function(){
				var me = this;
				var constraints = require('rtc-captureconfig')(me.capture).toConstraints();
				var media = require("rtc-media")({
					muted: me.muted,
					constraints: constraints
				});
				media.once('capture', function(stream){
					me.stream = stream;
					me.streamURI = window.URL.createObjectURL(stream);
				});
			}
		});
	</script>
</polymer-element>

<!--
The RTC Video
This displays our streamURI as a playing video
-->
<polymer-element name="rtc-video" attributes="src video playing muted">
	<template>
		<video id="video" mozSrcObject="{{src}}" src="{{src}}" muted="#{{muted}}" preserveaspectratio></video>
	</template>
	<script>
		Polymer('rtc-video', {
			video: null,
			ready: function(){
				this.refresh = this.refresh.bind(this);
				this.refresh();
			},
			refresh: function(){
				var me = this;
				var video = this.$.video;

				// Apply the element to our model for data binding
				me.video = video;

				// If we are playing, play the video
				if ( me.src && me.playing ) {
					setTimeout(function(){
						video.play();
					}, 0);
				}

				// If we are not playing, pause the video
				else {
					video.pause();
				}
			},
			srcChanged: function(){
				this.refresh();
			},
			playingChanged: function(){
				this.refresh();
			}
		});
	</script>
</polymer-element>

<!--
This RTC VideoProc
This takes a src (video element or streamURI — streamURI not support yet) and generates an imageURI with the filters applied
-->
<polymer-element name="rtc-videoproc" attributes="src filter fps mime quality greedy imageURI">
	<script src="//wzrd.in/bundle/dominject@latest"></script>
	<script src="//wzrd.in/bundle/rtc-videoproc-bal@latest"></script>
	<template>
		<canvas id="canvas"></canvas>
	</template>
	<script>
		Polymer('rtc-videoproc', {
			fps: 0.5,
			mime: 'image/jpeg',
			quality: 0.8,
			greedy: true,
			filter: null,  // grayscale
			filterLoaded: false,
			src: null,
			canvas: null,
			filterChanged: function(oldValue, newValue) {
				var me = this;
				if ( newValue ) {
					var filterSource = '//wzrd.in/bundle/rtc-filter-'+newValue+'@latest';
					var dominject = require('dominject');
					dominject({
						type: 'script',
						url: filterSource,
						next: function(err, element) {
							if ( err ) {
								console.log(err);
							} else {
								try {
									var filter = require('rtc-filter-'+me.filter);
									me.canvas.pipeline.add(filter);
								} catch (err) {
									console.log(err);
								}
							}
						}
					});
				}
			},
			srcChanged: function(oldValue, newValue) {
				var me = this;
				if ( newValue ) {
					me.canvas = require('rtc-videoproc-bal')({
						video: newValue,
						canvas: me.$.canvas,
						fps: me.fps,
						greedy: me.greedy
					});

					me.canvas.addEventListener('postprocess', function(event){
						me.imageURI = me.canvas.toDataURL(me.mime, me.quality);
					});
				}
			}
		});
	</script>
</polymer-element>

<!--
===============================================================================
-->

<!--
# The RTC Person
This is a view and model representing each person within the chat room.
Each person has a name, a video stream, and a low-bandwidth snapshot stream.
When the video stream is enabled, the low-bandwidth snapshot stream should
  be disabled and vice versa.
-->
<polymer-element name="rtc-person" attributes="talking streaming video name muted streamURI snapshotURI">
	<template>
		<div class="person">
			<label id="name">{{name}}</label>
			<rtc-video id="video" class="hidden" src="{{streamURI}}" video="{{video}}" muted="{{muted}}" playing="{{streaming}}"></rtc-video>
			<img id="image" class="hidden" src="{{snapshotURI}}" />
		</div>
	</template>
	<style>
		video, img {
			display: inline-block;
			width: 320px;
			height: 240px;
		}
		.person {
			display: inline-block;
			box-sizing: border-box;
			position: relative;
			border: 1px solid black;
			background: #EEE;
		}
		label {
			position: absolute;
			width: 100%;
			background: black;
			background: rgba(0,0,0,0.8);
			color: white;
			bottom: 0;
			left: 0;
		}
		.hidden {
			display: none;
		}
	</style>
	<script>
		Polymer('rtc-person', {
			streaming: false,
			muted: false,
			streamURI: null,
			snapshotURI: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
			ready: function(){
				this.refresh = this.refresh.bind(this);
				this.refresh();
			},
			refresh: function(){
				var me = this;
				var vid = this.$.video;
				var img = this.$.image;

				// If we are streaming, show the video
				if ( me.streamURI && me.streaming ) {
					vid.className = '';
					img.className = 'hidden';
				}

				// If we are not streaming, show the snapshot
				else {
					vid.className = 'hidden';
					img.className = '';
				}
			},
			streamURIChanged: function(){
				this.refresh();
			},
			streamingChanged: function(){
				this.refresh();
			}
		});
	</script>
</polymer-element>

<!--
# The RTC Room Panel
This is the display for our people within the chat room.
Talking people are arranged first. They will be displayed big (TODO).
Then it is ourself. Then the people streaming whom aren't muted.
Then the people streaming whom are muted.
Then finally, everyone else (the people in snapshot mode).
-->
<polymer-element name="rtc-room-panel" lightdom noscript>
	<template>
		<content select="[talking]"></content>
		<content select="rtc-person"></content>
		<content select="rtc-peer[streaming]:not([muted])"></content>
		<content select="rtc-peer[streaming][muted]"></content>
		<content select="*"></content>
	</template>
</polymer-element>

<!--
# The RTC App
This is us initialising our room and it working with all the magic.
-->
<polymer-element name="rtc-app" attributes="host room">
	<script src="//wzrd.in/bundle/rtc-quickconnect@latest"></script>
	<style>
		.hidden {
			display: none;
		}
	</style>
	<template>
		<rtc-media id="media" stream="{{myStream}}" streamURI="{{myStreamURI}}" muted></rtc-media>
		<rtc-videoproc id="snapshot" class="hidden" src="{{video}}" imageURI="{{mySnapshotURI}}" filter="grayscale"></rtc-videoproc>
		<rtc-room-panel id="people">
			<rtc-person id="me" name="You" streamURI="{{myStreamURI}}" video="{{video}}" streaming muted></rtc-person>
			<!--
			<rtc-peer peerID="..." streaming></rtc-peer>
			<rtc-peer peerID="..."></rtc-peer>
			<rtc-peer peerID="..."></rtc-peer>
			<rtc-peer peerID="..."></rtc-peer>
			-->
		</rtc-room-panel>
	</template>
	<script>
		Polymer('rtc-app', {
			room: 'interconnect',
			host: location.href.indexOf('github.io') !== -1 ? 'http://rtc.io/switchboard/' : location.href.replace(/(^.*\/).*$/, "$1"),
			snapshotURI: null,
			peers: null,
			myStream: null,
			startStream: function(peerID) {
				var me = this;
				var peer = me.getPeer(peerID);
				if ( !peer.streaming ) {
					var stream = me.myStream;
					console.log('start stream', peerID, stream);
					peer.connection.addStream(stream);

					//peer.removeAttribute('muted');
					//peer.setAttribute('streaming', '');
					peer.streaming = true;
					peer.muted = false;

					peer.sendMessage({
						action: 'started-stream'
					})
				}
			},
			stopStream: function(peerID) {
				var me = this;
				var peer = me.getPeer(peerID);
				if ( peer.streaming ) {
					var stream = me.myStream;
					console.log('stop stream', peerID, stream);
					peer.connection.removeStream(stream);

					//peer.removeAttribute('streaming');
					//peer.setAttribute('muted', '');
					peer.streaming = false;
					peer.muted = true;

					peer.sendMessage({
						action: 'stopped-stream'
					})
				}
			},
			getPeer: function(peerID) {
				var me = this;
				var peer = me.peers[peerID] || null;
				if ( peer === null ) {
					peer = document.createElement('rtc-person');
					me.peers[peerID] = peer;
					me.$.people.appendChild(peer);
				}
				return peer;
			},
			destroyPeer: function(peerID) {
				var me = this;
				var peer = me.peers[peerID] || null;
				if ( peer) {
					peer.parentNode.removeChild(peer);
					delete me.peers[peerID];
				}
				return null;
			},
			ready: function(){
				var me = this;
				me.peers = {};
				me.signaller = require('rtc-quickconnect')(me.host, {reactive: true, room: me.room, debug:false});
				me.signaller
					.createDataChannel('messages')
					.on('messages:open', function(peerChannel, peerID){
						var peer = me.getPeer(peerID);
						peer.channel = peerChannel;
						peer.channel.onmessage = function(event) {
							var data = JSON.parse(event.data || '{}') || {};
							if ( data.action !== 'snap' )  console.log('received message', data, 'from', peerID);
							console.log('remote stream', peerID, peer.connection.getLocalStreams(), peer.connection.getRemoteStreams());

							switch (data.action) {
								// Peer has sent their stream to us
								case 'started-stream':
									me.startStream(peerID);
									break;

								// Peer has cancelled their stream
								case 'stopped-stream':
									me.stopStream(peerID);
									break;

								case 'snap':
									peer.snapshotURI = data.snapshotURI;
									break;
							}
						}
					})
					.on('peer:connect', function(peerConnection, peerID, data, monitor){
						console.log('connected to', peerID);
						var peer = me.getPeer(peerID);
						peer.className += 'peer';
						peer.streaming = false;
						peer.muted = false;
						peer.connection = peerConnection;
						peer.name = peer.id = peerID;

						peer.sendMessage = function(data){
							if ( data.action !== 'snap' )  console.log('send message', data, 'to', peerID);
							var message = JSON.stringify(data);
							peer.channel.send(message);
						};

						peer.addEventListener('click', function(){
							if ( peer.streaming ) {
								me.stopStream(peerID);
							} else {
								me.startStream(peerID);
							}
						});

						peerConnection.onaddstream = function(event) {
							console.log('RECEIVED STREAM', 'from', peerID);
							peer.stream = event.stream;
							peer.streamURI = window.URL.createObjectURL(peer.stream);
							peer.stream.onended = function(){
								me.stopStream(peerId);
							}
							me.startStream(peerID);
						};
						peerConnection.onremovestream = function(event) {
							me.stopStream(peerId);
						};
					})
					.on('peer:leave', function(peerID){
						console.log('disconnected to', peerID);
						me.destroyPeer(peerID);
					});
			},
			mySnapshotURIChanged: function(oldValue, newValue){
				var me = this;
				if ( newValue ) {
					Object.keys(me.peers).forEach(function(peerID){
						var peer = me.peers[peerID];
						peer.sendMessage({
							action: 'snap',
							snapshotURI: newValue
						});
					});
				}
			}
		});
	</script>
</polymer-element>
